//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.08.22 at 06:13:18 PM EDT 
//


package com.slice.datatypes;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlList;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;


/**
 * <p>Java class for queryType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="queryType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="wholeWordOnly" type="{http://www.w3.org/2001/XMLSchema}boolean"/>
 *         &lt;element name="caseSensitive" type="{http://www.w3.org/2001/XMLSchema}boolean"/>
 *         &lt;element name="searchFileTypes" type="{http://www.slice.com/datatypes}intListType"/>
 *         &lt;element name="searchTerm" type="{http://www.slice.com/datatypes}valueListType"/>
 *         &lt;element name="pathExcludeFilterPatterns" type="{http://www.slice.com/datatypes}valueListType"/>
 *         &lt;element name="pathIncludeOnlyFilterPatterns" type="{http://www.slice.com/datatypes}valueListType"/>
 *         &lt;element name="pathIncludeComponentFilterPatterns" type="{http://www.slice.com/datatypes}valueListType"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "queryType", propOrder = {
    "wholeWordOnly",
    "caseSensitive",
    "searchFileTypes",
    "searchTerm",
    "pathExcludeFilterPatterns",
    "pathIncludeOnlyFilterPatterns",
    "pathIncludeComponentFilterPatterns"
})
public class QueryDTO {

    protected boolean wholeWordOnly;
    protected boolean caseSensitive;
    @XmlList
    @XmlElement(required = true)
    @XmlSchemaType(name = "anySimpleType")
    protected List<String> searchFileTypes;
    @XmlList
    @XmlElement(required = true)
    @XmlSchemaType(name = "anySimpleType")
    protected List<String> searchTerm;
    @XmlList
    @XmlElement(required = true)
    @XmlSchemaType(name = "anySimpleType")
    protected List<String> pathExcludeFilterPatterns;
    @XmlList
    @XmlElement(required = true)
    @XmlSchemaType(name = "anySimpleType")
    protected List<String> pathIncludeOnlyFilterPatterns;
    @XmlList
    @XmlElement(required = true)
    @XmlSchemaType(name = "anySimpleType")
    protected List<String> pathIncludeComponentFilterPatterns;

    /**
     * Gets the value of the wholeWordOnly property.
     * 
     */
    public boolean isWholeWordOnly() {
        return wholeWordOnly;
    }

    /**
     * Sets the value of the wholeWordOnly property.
     * 
     */
    public void setWholeWordOnly(boolean value) {
        this.wholeWordOnly = value;
    }

    /**
     * Gets the value of the caseSensitive property.
     * 
     */
    public boolean isCaseSensitive() {
        return caseSensitive;
    }

    /**
     * Sets the value of the caseSensitive property.
     * 
     */
    public void setCaseSensitive(boolean value) {
        this.caseSensitive = value;
    }

    /**
     * Gets the value of the searchFileTypes property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the searchFileTypes property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSearchFileTypes().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getSearchFileTypes() {
        if (searchFileTypes == null) {
            searchFileTypes = new ArrayList<String>();
        }
        return this.searchFileTypes;
    }

    /**
     * Gets the value of the searchTerm property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the searchTerm property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSearchTerm().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getSearchTerm() {
        if (searchTerm == null) {
            searchTerm = new ArrayList<String>();
        }
        return this.searchTerm;
    }

    /**
     * Gets the value of the pathExcludeFilterPatterns property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the pathExcludeFilterPatterns property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPathExcludeFilterPatterns().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getPathExcludeFilterPatterns() {
        if (pathExcludeFilterPatterns == null) {
            pathExcludeFilterPatterns = new ArrayList<String>();
        }
        return this.pathExcludeFilterPatterns;
    }

    /**
     * Gets the value of the pathIncludeOnlyFilterPatterns property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the pathIncludeOnlyFilterPatterns property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPathIncludeOnlyFilterPatterns().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getPathIncludeOnlyFilterPatterns() {
        if (pathIncludeOnlyFilterPatterns == null) {
            pathIncludeOnlyFilterPatterns = new ArrayList<String>();
        }
        return this.pathIncludeOnlyFilterPatterns;
    }

    /**
     * Gets the value of the pathIncludeComponentFilterPatterns property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the pathIncludeComponentFilterPatterns property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPathIncludeComponentFilterPatterns().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getPathIncludeComponentFilterPatterns() {
        if (pathIncludeComponentFilterPatterns == null) {
            pathIncludeComponentFilterPatterns = new ArrayList<String>();
        }
        return this.pathIncludeComponentFilterPatterns;
    }

}
